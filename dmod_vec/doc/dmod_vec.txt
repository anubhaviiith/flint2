/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************


******************************************************************************/


*******************************************************************************

    Memory management

*******************************************************************************

double _dmod_vec_init(slong len)

    Returns a vector of the given length. The entries are not necessarily
    zero.

void _dmod_vec_clear(double *vec)

    Frees the memory used by the given vector.

*******************************************************************************

    Modular reduction and arithmetic

*******************************************************************************

void dmod_init(dmod_t * mod, double n)

    Initialises the given \code{dmod_t} structure for reduction modulo $n$
    with a precomputed inverse.

double dmod_add(double a, double b, dmod_t mod)

    Returns $a + b$ modulo \code{mod.n}. It is assumed that $a$ and $b$ 
    are already reduced modulo \code{mod.n}.

double dmod_sub(double a, double b, dmod_t mod)

    Returns $a - b$ modulo \code{mod.n}. It is assumed that $a$ and $b$ 
    are already reduced modulo \code{mod.n}.


double dmod_mod_precomp(double a, dmod_t mod)
    
    Returns $a$ modulo \code{mod.n}. It is assumed that \code{mod.n} 
    is no more than \code{2 ^ FLINT_D_BITS} bits.
    
    $a$ modulo \code{mod.n} is calculated by the estimating the quotient which is $ a * \code{mod.ninv} $
    where \code{mod.ninv} is the precomputed inverse of \code{mod.n}.
    The error in the quotient is due to the rounding error in \code{mod.ninv} which is of 0.5 ULP.
    The largest value of 1 ULP = $2^(-52)$ for \code{mod.ninv}. Thus, this gives a maximal 
    error of 0.5 for $ \code{a} * \code{mod.ninv} $. 
    If the value of $ \code{rem} < 0.0 $ or $ \code{rem} \geq \code{mod.n} $, 
    means that an error is prevelant. The error will be of $+1$ or $-1$ after 
    truncation of quot to an integer. The remainder is thus adjusted appropriately 
    to give the correct value of $a$ modulo \code{mod.n}.
  



double dmod_mulmod_precomp(double c, double d, dmod_t mod)
    
    Returns $c * d$  modulo \code{mod.n}. It is assumed that \code{mod.n} 
    is no more than \code{2 ^ FLINT_D_BITS/2} bits. It is assumed that 
    $c$ and $d$ are already reduced modulo \code{mod.n}.

    The modulus is computed by estimating the quotient, $ \code{q} =  ( (c * d) * \code{mod.ninv}) $
    where \code{mod.ninv} is the precomputed inverse of \code{mod.n}.
    This difference comes from a summation of the rounding error in the product $(c*d) * \code{mod.ninv}$
    and a 0.5 ULP error from the error in the value of \code{mod.ninv}. The largest value 
    of 1 ULP = $2^(-52)$ for \code{mod.ninv}. This error is amplified by the factor of 
    $c * d$. This gives us a maximal error of $(0.5 * 2^(-52) * 2^52)$ which is equal to $0.5$. 
    The rounding error from the product $(c*d) * \code{mod.ninv}$ also comes out to be equal to $0.5$. 
    This gives a total error of $+1$ or $-1$ after truncation of quotient, \code{q} to an integer.

*******************************************************************************

    Dot Product

*******************************************************************************

double _dmod_vec_dot(const double * vec1, const double * vec2, slong len2, dmod_t mod);
    
    Returns the dot product of (\code{vec1}, \code{len}) and
    (\code{vec2}, \code{len})  


*******************************************************************************

    Arithmetic operations

*******************************************************************************

void _dmod_vec_add(double *res, double *vec1, 
                        double *vec2, slong len, dmod_t mod)

    Sets \code{(res, len)} to the sum of \code{(vec1, len)} 
    and \code{(vec2, len)}.

void _dmod_vec_sub(double *res, double *vec1, 
                        double *vec2, slong len, dmod_t mod)

    Sets \code{(res, len)} to the difference of \code{(vec1, len)} 
    and \code{(vec2, len)}.


void _dmod_vec_scalar_addmul(double * vec1, const double * vec2, 
                        const double alpha, slong len, dmod_t mod);
    
    Adds \code{(vec2, len)} times $alpha$ to the vector \code{(vec1, len)}.

void _dmod_vec_scalar_mul(double * vec1, const double alpha, 
                        slong len, dmod_t mod);
    
    Sets \code{(vec1, len)} to \code{(vec1, len)} multiplied by $alpha$.



*******************************************************************************

    Copy

*******************************************************************************

void _dmod_vec_copy(const double * vec1, double * vec2, slong len2);
    
    Sets \code{(vec2, len)} to \code{(vec1, len)}
